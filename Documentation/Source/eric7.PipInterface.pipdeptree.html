<!DOCTYPE html>
<html><head>
<title>eric7.PipInterface.pipdeptree</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<a NAME="top" ID="top"></a>
<h1>eric7.PipInterface.pipdeptree</h1>

<p>
Copyright (c) The pipdeptree developers
</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>
<h3>Global Attributes</h3>

<table>
<tr><td>__version__</td></tr><tr><td>__version_tuple__</td></tr><tr><td>flatten</td></tr>
</table>
<h3>Classes</h3>

<table>

<tr>
<td><a href="#DistPackage">DistPackage</a></td>
<td>Wrapper class for pkg_resources.Distribution instances</td>
</tr>
<tr>
<td><a href="#Package">Package</a></td>
<td>Abstract class for wrappers around objects that pip returns.</td>
</tr>
<tr>
<td><a href="#PackageDAG">PackageDAG</a></td>
<td>Representation of Package dependencies as directed acyclic graph using a dict (Mapping) as the underlying datastructure.</td>
</tr>
<tr>
<td><a href="#ReqPackage">ReqPackage</a></td>
<td>Wrapper class for Requirements instance</td>
</tr>
<tr>
<td><a href="#ReversedPackageDAG">ReversedPackageDAG</a></td>
<td>Representation of Package dependencies in the reverse order.</td>
</tr>
</table>
<h3>Functions</h3>

<table>

<tr>
<td><a href="#_get_args">_get_args</a></td>
<td></td>
</tr>
<tr>
<td><a href="#aux">aux</a></td>
<td></td>
</tr>
<tr>
<td><a href="#aux_1">aux</a></td>
<td></td>
</tr>
<tr>
<td><a href="#conflicting_deps">conflicting_deps</a></td>
<td>Returns dependencies which are not present or conflict with the requirements of other packages.</td>
</tr>
<tr>
<td><a href="#cyclic_deps">cyclic_deps</a></td>
<td>Return cyclic dependencies as list of tuples</td>
</tr>
<tr>
<td><a href="#dump_graphviz">dump_graphviz</a></td>
<td>Output dependency graph as one of the supported GraphViz output formats.</td>
</tr>
<tr>
<td><a href="#frozen_req_from_dist">frozen_req_from_dist</a></td>
<td></td>
</tr>
<tr>
<td><a href="#get_installed_distributions">get_installed_distributions</a></td>
<td></td>
</tr>
<tr>
<td><a href="#get_parser">get_parser</a></td>
<td></td>
</tr>
<tr>
<td><a href="#guess_version">guess_version</a></td>
<td>Guess the version of a pkg when pip doesn't provide it</td>
</tr>
<tr>
<td><a href="#handle_non_host_target">handle_non_host_target</a></td>
<td></td>
</tr>
<tr>
<td><a href="#main">main</a></td>
<td></td>
</tr>
<tr>
<td><a href="#mermaid_id">mermaid_id</a></td>
<td>Returns a valid Mermaid node ID from a string.</td>
</tr>
<tr>
<td><a href="#print_graphviz">print_graphviz</a></td>
<td>Dump the data generated by GraphViz to stdout.</td>
</tr>
<tr>
<td><a href="#render_conflicts_text">render_conflicts_text</a></td>
<td></td>
</tr>
<tr>
<td><a href="#render_cycles_text">render_cycles_text</a></td>
<td></td>
</tr>
<tr>
<td><a href="#render_json">render_json</a></td>
<td>Converts the tree into a flat json representation.</td>
</tr>
<tr>
<td><a href="#render_json_tree">render_json_tree</a></td>
<td>Converts the tree into a nested json representation.</td>
</tr>
<tr>
<td><a href="#render_mermaid">render_mermaid</a></td>
<td>Produce a Mermaid flowchart from the dependency graph.</td>
</tr>
<tr>
<td><a href="#render_text">render_text</a></td>
<td>Print tree as text on console</td>
</tr>
<tr>
<td><a href="#sorted_tree">sorted_tree</a></td>
<td>Sorts the dict representation of the tree.</td>
</tr>
</table>
<hr />
<hr />
<a NAME="DistPackage" ID="DistPackage"></a>
<h2>DistPackage</h2>

<p>
    Wrapper class for pkg_resources.Distribution instances
</p>
<p>
    :param obj: pkg_resources.Distribution to wrap over
    :param req: optional ReqPackage object to associate this DistPackage with. This is useful for displaying the tree
        in reverse
</p>
<h3>Derived from</h3>
Package
<h3>Class Attributes</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Class Methods</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Methods</h3>

<table>

<tr>
<td><a href="#DistPackage.__init__">DistPackage</a></td>
<td></td>
</tr>
<tr>
<td><a href="#DistPackage.as_dict">as_dict</a></td>
<td></td>
</tr>
<tr>
<td><a href="#DistPackage.as_parent_of">as_parent_of</a></td>
<td>Return a DistPackage instance associated to a requirement.</td>
</tr>
<tr>
<td><a href="#DistPackage.as_requirement">as_requirement</a></td>
<td>Return a ReqPackage representation of this DistPackage</td>
</tr>
<tr>
<td><a href="#DistPackage.render_as_branch">render_as_branch</a></td>
<td></td>
</tr>
<tr>
<td><a href="#DistPackage.render_as_root">render_as_root</a></td>
<td></td>
</tr>
</table>
<h3>Static Methods</h3>

<table>
<tr><td>None</td></tr>
</table>

<a NAME="DistPackage.__init__" ID="DistPackage.__init__"></a>
<h4>DistPackage (Constructor)</h4>
<b>DistPackage</b>(<i>obj, req=None</i>)

<a NAME="DistPackage.as_dict" ID="DistPackage.as_dict"></a>
<h4>DistPackage.as_dict</h4>
<b>as_dict</b>(<i></i>)

<a NAME="DistPackage.as_parent_of" ID="DistPackage.as_parent_of"></a>
<h4>DistPackage.as_parent_of</h4>
<b>as_parent_of</b>(<i>req</i>)

<p>
        Return a DistPackage instance associated to a requirement. This association is necessary for reversing the
        PackageDAG.
</p>
<p>
        If `req` is None, and the `req` attribute of the current instance is also None, then the same instance will be
        returned.
</p>
<p>
        :param ReqPackage req: the requirement to associate with
        :returns: DistPackage instance
</p>
<a NAME="DistPackage.as_requirement" ID="DistPackage.as_requirement"></a>
<h4>DistPackage.as_requirement</h4>
<b>as_requirement</b>(<i></i>)

<p>
Return a ReqPackage representation of this DistPackage
</p>
<a NAME="DistPackage.render_as_branch" ID="DistPackage.render_as_branch"></a>
<h4>DistPackage.render_as_branch</h4>
<b>render_as_branch</b>(<i>frozen</i>)

<a NAME="DistPackage.render_as_root" ID="DistPackage.render_as_root"></a>
<h4>DistPackage.render_as_root</h4>
<b>render_as_root</b>(<i>frozen</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="Package" ID="Package"></a>
<h2>Package</h2>

<p>
    Abstract class for wrappers around objects that pip returns. This class needs to be subclassed with implementations
    for `render_as_root` and `render_as_branch` methods.
</p>
<h3>Derived from</h3>
None
<h3>Class Attributes</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Class Methods</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Methods</h3>

<table>

<tr>
<td><a href="#Package.__init__">Package</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.__getattr__">__getattr__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.__lt__">__lt__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.__repr__">__repr__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.render">render</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.render_as_branch">render_as_branch</a></td>
<td></td>
</tr>
<tr>
<td><a href="#Package.render_as_root">render_as_root</a></td>
<td></td>
</tr>
</table>
<h3>Static Methods</h3>

<table>

<tr>
<td><a href="#Package.frozen_repr">frozen_repr</a></td>
<td></td>
</tr>
</table>

<a NAME="Package.__init__" ID="Package.__init__"></a>
<h4>Package (Constructor)</h4>
<b>Package</b>(<i>obj</i>)

<a NAME="Package.__getattr__" ID="Package.__getattr__"></a>
<h4>Package.__getattr__</h4>
<b>__getattr__</b>(<i>key</i>)

<a NAME="Package.__lt__" ID="Package.__lt__"></a>
<h4>Package.__lt__</h4>
<b>__lt__</b>(<i>rhs</i>)

<a NAME="Package.__repr__" ID="Package.__repr__"></a>
<h4>Package.__repr__</h4>
<b>__repr__</b>(<i></i>)

<a NAME="Package.render" ID="Package.render"></a>
<h4>Package.render</h4>
<b>render</b>(<i>parent=None, frozen=False</i>)

<a NAME="Package.render_as_branch" ID="Package.render_as_branch"></a>
<h4>Package.render_as_branch</h4>
<b>render_as_branch</b>(<i>frozen</i>)

<a NAME="Package.render_as_root" ID="Package.render_as_root"></a>
<h4>Package.render_as_root</h4>
<b>render_as_root</b>(<i>frozen</i>)

<a NAME="Package.frozen_repr" ID="Package.frozen_repr"></a>
<h4>Package.frozen_repr (static)</h4>
<b>frozen_repr</b>(<i></i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="PackageDAG" ID="PackageDAG"></a>
<h2>PackageDAG</h2>

<p>
    Representation of Package dependencies as directed acyclic graph using a dict (Mapping) as the underlying
    datastructure.
</p>
<p>
    The nodes and their relationships (edges) are internally stored using a map as follows,
</p>
<p>
    {a: [b, c],
     b: [d],
     c: [d, e],
     d: [e],
     e: [],
     f: [b],
     g: [e, f]}
</p>
<p>
    Here, node `a` has 2 children nodes `b` and `c`. Consider edge direction from `a` -> `b` and `a` -> `c`
    respectively.
</p>
<p>
    A node is expected to be an instance of a subclass of `Package`. The keys are must be of class `DistPackage` and
    each item in values must be of class `ReqPackage`. (See also ReversedPackageDAG where the key and value types are
    interchanged).
</p>
<h3>Derived from</h3>
Mapping
<h3>Class Attributes</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Class Methods</h3>

<table>

<tr>
<td><a href="#PackageDAG.from_pkgs">from_pkgs</a></td>
<td></td>
</tr>
</table>
<h3>Methods</h3>

<table>

<tr>
<td><a href="#PackageDAG.__init__">PackageDAG</a></td>
<td>Initialize the PackageDAG object</td>
</tr>
<tr>
<td><a href="#PackageDAG.__getitem__">__getitem__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#PackageDAG.__iter__">__iter__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#PackageDAG.__len__">__len__</a></td>
<td></td>
</tr>
<tr>
<td><a href="#PackageDAG.filter">filter</a></td>
<td>Filters nodes in a graph by given parameters</td>
</tr>
<tr>
<td><a href="#PackageDAG.get_children">get_children</a></td>
<td>Get child nodes for a node by its key</td>
</tr>
<tr>
<td><a href="#PackageDAG.get_node_as_parent">get_node_as_parent</a></td>
<td>Get the node from the keys of the dict representing the DAG.</td>
</tr>
<tr>
<td><a href="#PackageDAG.reverse">reverse</a></td>
<td>Reverse the DAG, or turn it upside-down.</td>
</tr>
<tr>
<td><a href="#PackageDAG.sort">sort</a></td>
<td>Return sorted tree in which the underlying _obj dict is an dict, sorted alphabetically by the keys.</td>
</tr>
</table>
<h3>Static Methods</h3>

<table>
<tr><td>None</td></tr>
</table>

<a NAME="PackageDAG.from_pkgs" ID="PackageDAG.from_pkgs"></a>
<h4>PackageDAG.from_pkgs (class method)</h4>
<b>from_pkgs</b>(<i>pkgs</i>)

<a NAME="PackageDAG.__init__" ID="PackageDAG.__init__"></a>
<h4>PackageDAG (Constructor)</h4>
<b>PackageDAG</b>(<i>m</i>)

<p>
Initialize the PackageDAG object
</p>
<p>
        :param dict m: dict of node objects (refer class docstring)
        :returns: None
        :rtype: NoneType
</p>
<p>

</p>
<a NAME="PackageDAG.__getitem__" ID="PackageDAG.__getitem__"></a>
<h4>PackageDAG.__getitem__</h4>
<b>__getitem__</b>(<i>*args</i>)

<a NAME="PackageDAG.__iter__" ID="PackageDAG.__iter__"></a>
<h4>PackageDAG.__iter__</h4>
<b>__iter__</b>(<i></i>)

<a NAME="PackageDAG.__len__" ID="PackageDAG.__len__"></a>
<h4>PackageDAG.__len__</h4>
<b>__len__</b>(<i></i>)

<a NAME="PackageDAG.filter" ID="PackageDAG.filter"></a>
<h4>PackageDAG.filter</h4>
<b>filter</b>(<i>include, exclude</i>)

<p>
        Filters nodes in a graph by given parameters
</p>
<p>
        If a node is included, then all it's children are also included.
</p>
<p>
        :param set include: set of node keys to include (or None)
        :param set exclude: set of node keys to exclude (or None)
        :returns: filtered version of the graph
        :rtype: PackageDAG
</p>
<a NAME="PackageDAG.get_children" ID="PackageDAG.get_children"></a>
<h4>PackageDAG.get_children</h4>
<b>get_children</b>(<i>node_key</i>)

<p>
        Get child nodes for a node by its key
</p>
<p>
        :param str node_key: key of the node to get children of
        :returns: list of child nodes
        :rtype: ReqPackage[]
</p>
<a NAME="PackageDAG.get_node_as_parent" ID="PackageDAG.get_node_as_parent"></a>
<h4>PackageDAG.get_node_as_parent</h4>
<b>get_node_as_parent</b>(<i>node_key</i>)

<p>
        Get the node from the keys of the dict representing the DAG.
</p>
<p>
        This method is useful if the dict representing the DAG contains different kind of objects in keys and values.
        Use this method to look up a node obj as a parent (from the keys of the dict) given a node key.
</p>
<p>
        :param node_key: identifier corresponding to key attr of node obj
        :returns: node obj (as present in the keys of the dict)
        :rtype: Object
</p>
<a NAME="PackageDAG.reverse" ID="PackageDAG.reverse"></a>
<h4>PackageDAG.reverse</h4>
<b>reverse</b>(<i></i>)

<p>
        Reverse the DAG, or turn it upside-down.
</p>
<p>
        In other words, the directions of edges of the nodes in the DAG will be reversed.
</p>
<p>
        Note that this function purely works on the nodes in the graph. This implies that to perform a combination of
        filtering and reversing, the order in which `filter` and `reverse` methods should be applied is important. For
        e.g., if reverse is called on a filtered graph, then only the filtered nodes and it's children will be
        considered when reversing. On the other hand, if filter is called on reversed DAG, then the definition of
        "child" nodes is as per the reversed DAG.
</p>
<p>
        :returns: DAG in the reversed form
        :rtype: ReversedPackageDAG
</p>
<a NAME="PackageDAG.sort" ID="PackageDAG.sort"></a>
<h4>PackageDAG.sort</h4>
<b>sort</b>(<i></i>)

<p>
        Return sorted tree in which the underlying _obj dict is an dict, sorted alphabetically by the keys.
</p>
<p>
        :returns: Instance of same class with dict
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="ReqPackage" ID="ReqPackage"></a>
<h2>ReqPackage</h2>

<p>
    Wrapper class for Requirements instance
</p>
<p>
    :param obj: The `Requirements` instance to wrap over
    :param dist: optional `pkg_resources.Distribution` instance for this requirement
</p>
<h3>Derived from</h3>
Package
<h3>Class Attributes</h3>

<table>
<tr><td>UNKNOWN_VERSION</td></tr>
</table>
<h3>Class Methods</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Methods</h3>

<table>

<tr>
<td><a href="#ReqPackage.__init__">ReqPackage</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.as_dict">as_dict</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.installed_version">installed_version</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.is_conflicting">is_conflicting</a></td>
<td>If installed version conflicts with required version</td>
</tr>
<tr>
<td><a href="#ReqPackage.is_missing">is_missing</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.render_as_branch">render_as_branch</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.render_as_root">render_as_root</a></td>
<td></td>
</tr>
<tr>
<td><a href="#ReqPackage.version_spec">version_spec</a></td>
<td></td>
</tr>
</table>
<h3>Static Methods</h3>

<table>
<tr><td>None</td></tr>
</table>

<a NAME="ReqPackage.__init__" ID="ReqPackage.__init__"></a>
<h4>ReqPackage (Constructor)</h4>
<b>ReqPackage</b>(<i>obj, dist=None</i>)

<a NAME="ReqPackage.as_dict" ID="ReqPackage.as_dict"></a>
<h4>ReqPackage.as_dict</h4>
<b>as_dict</b>(<i></i>)

<a NAME="ReqPackage.installed_version" ID="ReqPackage.installed_version"></a>
<h4>ReqPackage.installed_version</h4>
<b>installed_version</b>(<i></i>)

<a NAME="ReqPackage.is_conflicting" ID="ReqPackage.is_conflicting"></a>
<h4>ReqPackage.is_conflicting</h4>
<b>is_conflicting</b>(<i></i>)

<p>
If installed version conflicts with required version
</p>
<a NAME="ReqPackage.is_missing" ID="ReqPackage.is_missing"></a>
<h4>ReqPackage.is_missing</h4>
<b>is_missing</b>(<i></i>)

<a NAME="ReqPackage.render_as_branch" ID="ReqPackage.render_as_branch"></a>
<h4>ReqPackage.render_as_branch</h4>
<b>render_as_branch</b>(<i>frozen</i>)

<a NAME="ReqPackage.render_as_root" ID="ReqPackage.render_as_root"></a>
<h4>ReqPackage.render_as_root</h4>
<b>render_as_root</b>(<i>frozen</i>)

<a NAME="ReqPackage.version_spec" ID="ReqPackage.version_spec"></a>
<h4>ReqPackage.version_spec</h4>
<b>version_spec</b>(<i></i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="ReversedPackageDAG" ID="ReversedPackageDAG"></a>
<h2>ReversedPackageDAG</h2>

<p>
Representation of Package dependencies in the reverse order.
</p>
<p>
    Similar to it's super class `PackageDAG`, the underlying datastructure is a dict, but here the keys are expected to
    be of type `ReqPackage` and each item in the values of type `DistPackage`.
</p>
<p>
    Typically, this object will be obtained by calling `PackageDAG.reverse`.
</p>
<h3>Derived from</h3>
PackageDAG
<h3>Class Attributes</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Class Methods</h3>

<table>
<tr><td>None</td></tr>
</table>
<h3>Methods</h3>

<table>

<tr>
<td><a href="#ReversedPackageDAG.reverse">reverse</a></td>
<td>Reverse the already reversed DAG to get the PackageDAG again</td>
</tr>
</table>
<h3>Static Methods</h3>

<table>
<tr><td>None</td></tr>
</table>

<a NAME="ReversedPackageDAG.reverse" ID="ReversedPackageDAG.reverse"></a>
<h4>ReversedPackageDAG.reverse</h4>
<b>reverse</b>(<i></i>)

<p>
        Reverse the already reversed DAG to get the PackageDAG again
</p>
<p>
        :returns: reverse of the reversed DAG
        :rtype: PackageDAG
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="_get_args" ID="_get_args"></a>
<h2>_get_args</h2>
<b>_get_args</b>(<i></i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="aux" ID="aux"></a>
<h2>aux</h2>
<b>aux</b>(<i>node, parent=None, indent=0, cur_chain=None</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="aux_1" ID="aux_1"></a>
<h2>aux</h2>
<b>aux</b>(<i>node, parent=None, cur_chain=None</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="conflicting_deps" ID="conflicting_deps"></a>
<h2>conflicting_deps</h2>
<b>conflicting_deps</b>(<i>tree</i>)

<p>
    Returns dependencies which are not present or conflict with the requirements of other packages.
</p>
<p>
    e.g. will warn if pkg1 requires pkg2==2.0 and pkg2==1.0 is installed
</p>
<p>
    :param tree: the requirements tree (dict)
    :returns: dict of DistPackage -> list of unsatisfied/unknown ReqPackage
    :rtype: dict
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="cyclic_deps" ID="cyclic_deps"></a>
<h2>cyclic_deps</h2>
<b>cyclic_deps</b>(<i>tree</i>)

<p>
    Return cyclic dependencies as list of tuples
</p>
<p>
    :param PackageDAG tree: package tree/dag
    :returns: list of tuples representing cyclic dependencies
    :rtype: list
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="dump_graphviz" ID="dump_graphviz"></a>
<h2>dump_graphviz</h2>
<b>dump_graphviz</b>(<i>tree, output_format="dot", is_reverse=False</i>)

<p>
Output dependency graph as one of the supported GraphViz output formats.
</p>
<p>
    :param dict tree: dependency graph
    :param string output_format: output format
    :param bool is_reverse: reverse or not
    :returns: representation of tree in the specified output format
    :rtype: str or binary representation depending on the output format
</p>
<p>

</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="frozen_req_from_dist" ID="frozen_req_from_dist"></a>
<h2>frozen_req_from_dist</h2>
<b>frozen_req_from_dist</b>(<i>dist</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="get_installed_distributions" ID="get_installed_distributions"></a>
<h2>get_installed_distributions</h2>
<b>get_installed_distributions</b>(<i>local_only=False, user_only=False</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="get_parser" ID="get_parser"></a>
<h2>get_parser</h2>
<b>get_parser</b>(<i></i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="guess_version" ID="guess_version"></a>
<h2>guess_version</h2>
<b>guess_version</b>(<i>pkg_key, default="?"</i>)

<p>
Guess the version of a pkg when pip doesn't provide it
</p>
<p>
    :param str pkg_key: key of the package
    :param str default: default version to return if unable to find
    :returns: version
    :rtype: string
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="handle_non_host_target" ID="handle_non_host_target"></a>
<h2>handle_non_host_target</h2>
<b>handle_non_host_target</b>(<i>args</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="main" ID="main"></a>
<h2>main</h2>
<b>main</b>(<i></i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="mermaid_id" ID="mermaid_id"></a>
<h2>mermaid_id</h2>
<b>mermaid_id</b>(<i>key: str</i>)

<p>
Returns a valid Mermaid node ID from a string.
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="print_graphviz" ID="print_graphviz"></a>
<h2>print_graphviz</h2>
<b>print_graphviz</b>(<i>dump_output</i>)

<p>
    Dump the data generated by GraphViz to stdout.
</p>
<p>
    :param dump_output: The output from dump_graphviz
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_conflicts_text" ID="render_conflicts_text"></a>
<h2>render_conflicts_text</h2>
<b>render_conflicts_text</b>(<i>conflicts</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_cycles_text" ID="render_cycles_text"></a>
<h2>render_cycles_text</h2>
<b>render_cycles_text</b>(<i>cycles</i>)

<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_json" ID="render_json"></a>
<h2>render_json</h2>
<b>render_json</b>(<i>tree, indent</i>)

<p>
    Converts the tree into a flat json representation.
</p>
<p>
    The json repr will be a list of hashes, each hash having 2 fields:
      - package
      - dependencies: list of dependencies
</p>
<p>
    :param dict tree: dependency tree
    :param int indent: no. of spaces to indent json
    :returns: json representation of the tree
    :rtype: str
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_json_tree" ID="render_json_tree"></a>
<h2>render_json_tree</h2>
<b>render_json_tree</b>(<i>tree, indent</i>)

<p>
    Converts the tree into a nested json representation.
</p>
<p>
    The json repr will be a list of hashes, each hash having the following fields:
</p>
<p>
      - package_name
      - key
      - required_version
      - installed_version
      - dependencies: list of dependencies
</p>
<p>
    :param dict tree: dependency tree
    :param int indent: no. of spaces to indent json
    :returns: json representation of the tree
    :rtype: str
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_mermaid" ID="render_mermaid"></a>
<h2>render_mermaid</h2>
<b>render_mermaid</b>(<i>tree</i>)

<p>
Produce a Mermaid flowchart from the dependency graph.
</p>
<p>
    :param dict tree: dependency graph
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="render_text" ID="render_text"></a>
<h2>render_text</h2>
<b>render_text</b>(<i>tree, list_all=True, frozen=False</i>)

<p>
Print tree as text on console
</p>
<p>
    :param dict tree: the package tree
    :param bool list_all: whether to list all the pgks at the root level or only those that are the sub-dependencies
    :param bool frozen: show the names of the pkgs in the output that's favourable to pip --freeze
    :returns: None
</p>
<p>

</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="sorted_tree" ID="sorted_tree"></a>
<h2>sorted_tree</h2>
<b>sorted_tree</b>(<i>tree</i>)

<p>
    Sorts the dict representation of the tree. The root packages as well as the intermediate packages are sorted in the
    alphabetical order of the package names.
</p>
<p>
    :param dict tree: the pkg dependency tree obtained by calling `construct_tree` function
    :returns: sorted tree
    :rtype: dict
</p>
<div align="right"><a href="#top">Up</a></div>
<hr />
</body></html>