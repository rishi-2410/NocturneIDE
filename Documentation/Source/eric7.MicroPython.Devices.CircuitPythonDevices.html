<!DOCTYPE html>
<html><head>
<title>eric7.MicroPython.Devices.CircuitPythonDevices</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<a NAME="top" ID="top"></a>
<h1>eric7.MicroPython.Devices.CircuitPythonDevices</h1>
<p>
Module implementing the device interface class for CircuitPython boards.
</p>

<h3>Global Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Classes</h3>
<table>
<tr>
<td><a href="#CircuitPythonDevice">CircuitPythonDevice</a></td>
<td>Class implementing the device for CircuitPython boards.</td>
</tr>
</table>

<h3>Functions</h3>
<table>
<tr>
<td><a href="#createDevice">createDevice</a></td>
<td>Function to instantiate a MicroPython device object.</td>
</tr>
</table>

<hr />
<hr />
<a NAME="CircuitPythonDevice" ID="CircuitPythonDevice"></a>
<h2>CircuitPythonDevice</h2>
<p>
    Class implementing the device for CircuitPython boards.
</p>

<h3>Derived from</h3>
BaseDevice
<h3>Class Attributes</h3>
<table>
<tr><td>DeviceVolumeName</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr>
<td><a href="#CircuitPythonDevice.__init__">CircuitPythonDevice</a></td>
<td>Constructor</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__aboutToShowLibraryMenu">__aboutToShowLibraryMenu</a></td>
<td>Private slot to populate the 'Library Management' menu.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__activateBootloader">__activateBootloader</a></td>
<td>Private slot to switch the board into 'bootloader' mode.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__activateUF2Boot">__activateUF2Boot</a></td>
<td>Private slot to switch the board into 'UF2 Boot' mode.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__cpyVersionResponse">__cpyVersionResponse</a></td>
<td>Private slot handling the response of the latest version request.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__createCPyMenu">__createCPyMenu</a></td>
<td>Private method to create the CircuitPython submenu.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__createFlashMenus">__createFlashMenus</a></td>
<td>Private method to create the various menus to flash a CircuitPython firmware.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__deviceVolumeMounted">__deviceVolumeMounted</a></td>
<td>Private method to check, if the device volume is mounted.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__esp32EraseFlash">__esp32EraseFlash</a></td>
<td>Private slot to erase the flash of an ESP32 device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__esp32FlashAddons">__esp32FlashAddons</a></td>
<td>Private slot to flash additional firmware to an ESP32 device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__esp32FlashPython">__esp32FlashPython</a></td>
<td>Private slot to flash a MicroPython or CircuitPython firmware to an ESP32 device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__findDeviceDirectories">__findDeviceDirectories</a></td>
<td>Private method to find the device directories associated with the current board name.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__findWorkspace">__findWorkspace</a></td>
<td>Private method to find the workspace directory.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__flashCircuitPython">__flashCircuitPython</a></td>
<td>Private slot to flash a CircuitPython firmware to a device supporting UF2.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__installLibraryFiles">__installLibraryFiles</a></td>
<td>Private slot to install Python files into the onboard library.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__modifySettings">__modifySettings</a></td>
<td>Private method to modify the 'settings.toml' file as of CircuitPython 8.0.0.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__resetDevice">__resetDevice</a></td>
<td>Private slot to reset the connected device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__selectDeviceVolume">__selectDeviceVolume</a></td>
<td>Private slot to select the mounted device volume, if it could not be found automatically.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__showTeensyFlashInstructions">__showTeensyFlashInstructions</a></td>
<td>Private slot to show a message box because Teensy does not support the UF2 bootloader yet.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.__startTeensyLoader">__startTeensyLoader</a></td>
<td>Private slot to start the 'Teensy Loader' application.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.activateBluetoothInterface">activateBluetoothInterface</a></td>
<td>Public method to activate the Bluetooth interface.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.addDeviceMenuEntries">addDeviceMenuEntries</a></td>
<td>Public method to add device specific entries to the given menu.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.canRunScript">canRunScript</a></td>
<td>Public method to determine, if a script can be executed.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.canStartFileManager">canStartFileManager</a></td>
<td>Public method to determine, if a File Manager can be started.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.canStartPlotter">canStartPlotter</a></td>
<td>Public method to determine, if a Plotter can be started.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.canStartRepl">canStartRepl</a></td>
<td>Public method to determine, if a REPL can be started.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.checkInternet">checkInternet</a></td>
<td>Public method to check, if the internet can be reached.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.checkInternetViaLan">checkInternetViaLan</a></td>
<td>Public method to check, if the internet can be reached (LAN variant).</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.connectToLan">connectToLan</a></td>
<td>Public method to connect the connected device to the LAN.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.connectWifi">connectWifi</a></td>
<td>Public method to connect a device to a WiFi network.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.deactivateBluetoothInterface">deactivateBluetoothInterface</a></td>
<td>Public method to deactivate the Bluetooth interface.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.deactivateEthernet">deactivateEthernet</a></td>
<td>Public method to deactivate the Ethernet interface of the connected device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.deactivateInterface">deactivateInterface</a></td>
<td>Public method to deactivate a given WiFi interface of the connected device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.deviceName">deviceName</a></td>
<td>Public method to get the name of the device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.disconnectFromLan">disconnectFromLan</a></td>
<td>Public method  to disconnect from the LAN.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.disconnectWifi">disconnectWifi</a></td>
<td>Public method to disconnect a device from the WiFi network.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.forceInterrupt">forceInterrupt</a></td>
<td>Public method to determine the need for an interrupt when opening the serial connection.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getBluetoothStatus">getBluetoothStatus</a></td>
<td>Public method to get Bluetooth status data of the connected board.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getConnectedClients">getConnectedClients</a></td>
<td>Public method to get a list of connected clients.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getDeviceScan">getDeviceScan</a></td>
<td>Public method to perform a Bluetooth device scan.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getDocumentationUrl">getDocumentationUrl</a></td>
<td>Public method to get the device documentation URL.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getDownloadMenuEntries">getDownloadMenuEntries</a></td>
<td>Public method to retrieve the entries for the downloads menu.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getEthernetStatus">getEthernetStatus</a></td>
<td>Public method to get Ethernet status data of the connected board.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getWifiData">getWifiData</a></td>
<td>Public method to get data related to the current WiFi status.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.getWorkspace">getWorkspace</a></td>
<td>Public method to get the workspace directory.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.hasBluetooth">hasBluetooth</a></td>
<td>Public method to check the availability of Bluetooth.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.hasEthernet">hasEthernet</a></td>
<td>Public method to check the availability of Ethernet.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.hasFlashMenuEntry">hasFlashMenuEntry</a></td>
<td>Public method to check, if the device has its own flash menu entry.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.hasNetworkTime">hasNetworkTime</a></td>
<td>Public method to check the availability of network time functions.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.hasWifi">hasWifi</a></td>
<td>Public method to check the availability of WiFi.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.isLanConnected">isLanConnected</a></td>
<td>Public method to check the LAN connection status.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.isWifiApConnected">isWifiApConnected</a></td>
<td>Public method to check the WiFi connection status as access point.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.isWifiClientConnected">isWifiClientConnected</a></td>
<td>Public method to check the WiFi connection status as client.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.removeCredentials">removeCredentials</a></td>
<td>Public method to remove the saved credentials from the connected device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.removeLanAutoConnect">removeLanAutoConnect</a></td>
<td>Public method to remove the saved IPv4 parameters from the connected device.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.runScript">runScript</a></td>
<td>Public method to run the given Python script.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.scanNetworks">scanNetworks</a></td>
<td>Public method to scan for available WiFi networks.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.setButtons">setButtons</a></td>
<td>Public method to enable the supported action buttons.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.setConnected">setConnected</a></td>
<td>Public method to set the connection state.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.setNetworkTime">setNetworkTime</a></td>
<td>Public method to set the time to the network time retrieved from an NTP server.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.setWorkspace">setWorkspace</a></td>
<td>Public method to set the device workspace directory.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.showCircuitPythonVersions">showCircuitPythonVersions</a></td>
<td>Public slot to show the CircuitPython version of a connected device and the latest available one (from Github).</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.startAccessPoint">startAccessPoint</a></td>
<td>Public method to start the access point interface.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.stopAccessPoint">stopAccessPoint</a></td>
<td>Public method to stop the access point interface.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.supportsLocalFileAccess">supportsLocalFileAccess</a></td>
<td>Public method to indicate file access via a local directory.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.writeCredentials">writeCredentials</a></td>
<td>Public method to write the given credentials to the connected device and modify the start script to connect automatically.</td>
</tr>
<tr>
<td><a href="#CircuitPythonDevice.writeLanAutoConnect">writeLanAutoConnect</a></td>
<td>Public method to generate a script and associated configuration to connect the device to the LAN during boot time.</td>
</tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<a NAME="CircuitPythonDevice.__init__" ID="CircuitPythonDevice.__init__"></a>
<h4>CircuitPythonDevice (Constructor)</h4>
<b>CircuitPythonDevice</b>(<i>microPythonWidget, deviceType, boardName, vid=0, pid=0, hasWorkspace=True, parent=None, </i>)
<p>
        Constructor
</p>

<dl>

<dt><i>microPythonWidget</i> (MicroPythonWidget)</dt>
<dd>
reference to the main MicroPython widget
</dd>
<dt><i>deviceType</i> (str)</dt>
<dd>
device type assigned to this device interface
</dd>
<dt><i>boardName</i> (str)</dt>
<dd>
name of the board
</dd>
<dt><i>vid</i> (int (optional))</dt>
<dd>
vendor ID (defaults to 0)
</dd>
<dt><i>pid</i> (int (optional))</dt>
<dd>
product ID (defaults to 0)
</dd>
<dt><i>hasWorkspace</i> (bool (optional))</dt>
<dd>
flag indicating that the devices supports access via
            a mounted volume (defaults to True)
</dd>
<dt><i>parent</i> (QObject)</dt>
<dd>
reference to the parent object
</dd>
</dl>
<a NAME="CircuitPythonDevice.__aboutToShowLibraryMenu" ID="CircuitPythonDevice.__aboutToShowLibraryMenu"></a>
<h4>CircuitPythonDevice.__aboutToShowLibraryMenu</h4>
<b>__aboutToShowLibraryMenu</b>(<i></i>)
<p>
        Private slot to populate the 'Library Management' menu.
</p>

<a NAME="CircuitPythonDevice.__activateBootloader" ID="CircuitPythonDevice.__activateBootloader"></a>
<h4>CircuitPythonDevice.__activateBootloader</h4>
<b>__activateBootloader</b>(<i></i>)
<p>
        Private slot to switch the board into 'bootloader' mode.
</p>

<a NAME="CircuitPythonDevice.__activateUF2Boot" ID="CircuitPythonDevice.__activateUF2Boot"></a>
<h4>CircuitPythonDevice.__activateUF2Boot</h4>
<b>__activateUF2Boot</b>(<i></i>)
<p>
        Private slot to switch the board into 'UF2 Boot' mode.
</p>

<a NAME="CircuitPythonDevice.__cpyVersionResponse" ID="CircuitPythonDevice.__cpyVersionResponse"></a>
<h4>CircuitPythonDevice.__cpyVersionResponse</h4>
<b>__cpyVersionResponse</b>(<i>reply</i>)
<p>
        Private slot handling the response of the latest version request.
</p>

<dl>

<dt><i>reply</i> (QNetworkReply)</dt>
<dd>
reference to the reply object
</dd>
</dl>
<a NAME="CircuitPythonDevice.__createCPyMenu" ID="CircuitPythonDevice.__createCPyMenu"></a>
<h4>CircuitPythonDevice.__createCPyMenu</h4>
<b>__createCPyMenu</b>(<i></i>)
<p>
        Private method to create the CircuitPython submenu.
</p>

<a NAME="CircuitPythonDevice.__createFlashMenus" ID="CircuitPythonDevice.__createFlashMenus"></a>
<h4>CircuitPythonDevice.__createFlashMenus</h4>
<b>__createFlashMenus</b>(<i></i>)
<p>
        Private method to create the various menus to flash a CircuitPython firmware.
</p>

<dl>
<dt>Return:</dt>
<dd>
reference to the created top level flash menu
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
QMenu
</dd>
</dl>
<a NAME="CircuitPythonDevice.__deviceVolumeMounted" ID="CircuitPythonDevice.__deviceVolumeMounted"></a>
<h4>CircuitPythonDevice.__deviceVolumeMounted</h4>
<b>__deviceVolumeMounted</b>(<i></i>)
<p>
        Private method to check, if the device volume is mounted.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicated a mounted device
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.__esp32EraseFlash" ID="CircuitPythonDevice.__esp32EraseFlash"></a>
<h4>CircuitPythonDevice.__esp32EraseFlash</h4>
<b>__esp32EraseFlash</b>(<i></i>)
<p>
        Private slot to erase the flash of an ESP32 device.
</p>

<a NAME="CircuitPythonDevice.__esp32FlashAddons" ID="CircuitPythonDevice.__esp32FlashAddons"></a>
<h4>CircuitPythonDevice.__esp32FlashAddons</h4>
<b>__esp32FlashAddons</b>(<i></i>)
<p>
        Private slot to flash additional firmware to an ESP32 device.
</p>

<a NAME="CircuitPythonDevice.__esp32FlashPython" ID="CircuitPythonDevice.__esp32FlashPython"></a>
<h4>CircuitPythonDevice.__esp32FlashPython</h4>
<b>__esp32FlashPython</b>(<i></i>)
<p>
        Private slot to flash a MicroPython or CircuitPython firmware to an ESP32
        device.
</p>

<a NAME="CircuitPythonDevice.__findDeviceDirectories" ID="CircuitPythonDevice.__findDeviceDirectories"></a>
<h4>CircuitPythonDevice.__findDeviceDirectories</h4>
<b>__findDeviceDirectories</b>(<i>directories</i>)
<p>
        Private method to find the device directories associated with the
        current board name.
</p>

<dl>

<dt><i>directories</i> (list of str)</dt>
<dd>
list of directories to be checked
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
list of associated directories
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of str
</dd>
</dl>
<a NAME="CircuitPythonDevice.__findWorkspace" ID="CircuitPythonDevice.__findWorkspace"></a>
<h4>CircuitPythonDevice.__findWorkspace</h4>
<b>__findWorkspace</b>(<i>silent=False</i>)
<p>
        Private method to find the workspace directory.
</p>

<dl>

<dt><i>silent</i> (bool (optional))</dt>
<dd>
flag indicating silent operations (defaults to False)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
workspace directory used for saving files
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="CircuitPythonDevice.__flashCircuitPython" ID="CircuitPythonDevice.__flashCircuitPython"></a>
<h4>CircuitPythonDevice.__flashCircuitPython</h4>
<b>__flashCircuitPython</b>(<i></i>)
<p>
        Private slot to flash a CircuitPython firmware to a device supporting UF2.
</p>

<a NAME="CircuitPythonDevice.__installLibraryFiles" ID="CircuitPythonDevice.__installLibraryFiles"></a>
<h4>CircuitPythonDevice.__installLibraryFiles</h4>
<b>__installLibraryFiles</b>(<i>packageMode=False</i>)
<p>
        Private slot to install Python files into the onboard library.
</p>

<dl>

<dt><i>packageMode</i> (bool (optional))</dt>
<dd>
flag indicating to install a library package
            (defaults to False)
</dd>
</dl>
<a NAME="CircuitPythonDevice.__modifySettings" ID="CircuitPythonDevice.__modifySettings"></a>
<h4>CircuitPythonDevice.__modifySettings</h4>
<b>__modifySettings</b>(<i>changedEntries</i>)
<p>
        Private method to modify the 'settings.toml' file as of CircuitPython 8.0.0.
</p>

<dl>

<dt><i>changedEntries</i> (dict of {str: str})</dt>
<dd>
dictionary containing the TOML entries to be changed
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a success flag and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.__resetDevice" ID="CircuitPythonDevice.__resetDevice"></a>
<h4>CircuitPythonDevice.__resetDevice</h4>
<b>__resetDevice</b>(<i></i>)
<p>
        Private slot to reset the connected device.
</p>

<a NAME="CircuitPythonDevice.__selectDeviceVolume" ID="CircuitPythonDevice.__selectDeviceVolume"></a>
<h4>CircuitPythonDevice.__selectDeviceVolume</h4>
<b>__selectDeviceVolume</b>(<i></i>)
<p>
        Private slot to select the mounted device volume, if it could not be found
        automatically.
</p>

<a NAME="CircuitPythonDevice.__showTeensyFlashInstructions" ID="CircuitPythonDevice.__showTeensyFlashInstructions"></a>
<h4>CircuitPythonDevice.__showTeensyFlashInstructions</h4>
<b>__showTeensyFlashInstructions</b>(<i></i>)
<p>
        Private slot to show a message box because Teensy does not support
        the UF2 bootloader yet.
</p>

<a NAME="CircuitPythonDevice.__startTeensyLoader" ID="CircuitPythonDevice.__startTeensyLoader"></a>
<h4>CircuitPythonDevice.__startTeensyLoader</h4>
<b>__startTeensyLoader</b>(<i></i>)
<p>
        Private slot to start the 'Teensy Loader' application.
</p>
<p>
        Note: The application must be accessible via the application search path.
</p>

<a NAME="CircuitPythonDevice.activateBluetoothInterface" ID="CircuitPythonDevice.activateBluetoothInterface"></a>
<h4>CircuitPythonDevice.activateBluetoothInterface</h4>
<b>activateBluetoothInterface</b>(<i></i>)
<p>
        Public method to activate the Bluetooth interface.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the new state of the Bluetooth interface
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.addDeviceMenuEntries" ID="CircuitPythonDevice.addDeviceMenuEntries"></a>
<h4>CircuitPythonDevice.addDeviceMenuEntries</h4>
<b>addDeviceMenuEntries</b>(<i>menu</i>)
<p>
        Public method to add device specific entries to the given menu.
</p>

<dl>

<dt><i>menu</i> (QMenu)</dt>
<dd>
reference to the context menu
</dd>
</dl>
<a NAME="CircuitPythonDevice.canRunScript" ID="CircuitPythonDevice.canRunScript"></a>
<h4>CircuitPythonDevice.canRunScript</h4>
<b>canRunScript</b>(<i></i>)
<p>
        Public method to determine, if a script can be executed.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating it is safe to start a
            Plotter and a reason why it cannot.
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.canStartFileManager" ID="CircuitPythonDevice.canStartFileManager"></a>
<h4>CircuitPythonDevice.canStartFileManager</h4>
<b>canStartFileManager</b>(<i></i>)
<p>
        Public method to determine, if a File Manager can be started.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating it is safe to start a
            File Manager and a reason why it cannot.
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.canStartPlotter" ID="CircuitPythonDevice.canStartPlotter"></a>
<h4>CircuitPythonDevice.canStartPlotter</h4>
<b>canStartPlotter</b>(<i></i>)
<p>
        Public method to determine, if a Plotter can be started.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating it is safe to start a
            Plotter and a reason why it cannot.
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.canStartRepl" ID="CircuitPythonDevice.canStartRepl"></a>
<h4>CircuitPythonDevice.canStartRepl</h4>
<b>canStartRepl</b>(<i></i>)
<p>
        Public method to determine, if a REPL can be started.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating it is safe to start a REPL
            and a reason why it cannot.
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.checkInternet" ID="CircuitPythonDevice.checkInternet"></a>
<h4>CircuitPythonDevice.checkInternet</h4>
<b>checkInternet</b>(<i></i>)
<p>
        Public method to check, if the internet can be reached.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating reachability and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.checkInternetViaLan" ID="CircuitPythonDevice.checkInternetViaLan"></a>
<h4>CircuitPythonDevice.checkInternetViaLan</h4>
<b>checkInternetViaLan</b>(<i></i>)
<p>
        Public method to check, if the internet can be reached (LAN variant).
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating reachability and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.connectToLan" ID="CircuitPythonDevice.connectToLan"></a>
<h4>CircuitPythonDevice.connectToLan</h4>
<b>connectToLan</b>(<i>config, hostname</i>)
<p>
        Public method to connect the connected device to the LAN.
</p>
<p>
        Note: The MAC address of the interface is configured with the WIZ
</p>

<dl>

<dt><i>config</i> (str or tuple of (str, str, str, str))</dt>
<dd>
configuration for the connection (either the string 'dhcp'
            for a dynamic address or a tuple of four strings with the IPv4 parameters.
</dd>
<dt><i>hostname</i> (str)</dt>
<dd>
host name of the device
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.connectWifi" ID="CircuitPythonDevice.connectWifi"></a>
<h4>CircuitPythonDevice.connectWifi</h4>
<b>connectWifi</b>(<i>ssid, password, hostname</i>)
<p>
        Public method to connect a device to a WiFi network.
</p>

<dl>

<dt><i>ssid</i> (str)</dt>
<dd>
name (SSID) of the WiFi network
</dd>
<dt><i>password</i> (str)</dt>
<dd>
password needed to connect
</dd>
<dt><i>hostname</i> (str)</dt>
<dd>
host name of the device
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing the connection status and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.deactivateBluetoothInterface" ID="CircuitPythonDevice.deactivateBluetoothInterface"></a>
<h4>CircuitPythonDevice.deactivateBluetoothInterface</h4>
<b>deactivateBluetoothInterface</b>(<i></i>)
<p>
        Public method to deactivate the Bluetooth interface.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the new state of the Bluetooth interface
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.deactivateEthernet" ID="CircuitPythonDevice.deactivateEthernet"></a>
<h4>CircuitPythonDevice.deactivateEthernet</h4>
<b>deactivateEthernet</b>(<i></i>)
<p>
        Public method to deactivate the Ethernet interface of the connected device.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containg a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.deactivateInterface" ID="CircuitPythonDevice.deactivateInterface"></a>
<h4>CircuitPythonDevice.deactivateInterface</h4>
<b>deactivateInterface</b>(<i>interface</i>)
<p>
        Public method to deactivate a given WiFi interface of the connected device.
</p>
<p>
        Note: With CircuitPython it is not possible to deactivate the station and
        access point interfaces separately.
</p>

<dl>

<dt><i>interface</i> (str)</dt>
<dd>
designation of the interface to be deactivated (one of 'AP'
            or 'STA')
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containg a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<dl>

<dt>Raises <b>ValueError</b>:</dt>
<dd>
raised to indicate a wrong value for the interface type
</dd>
</dl>
<a NAME="CircuitPythonDevice.deviceName" ID="CircuitPythonDevice.deviceName"></a>
<h4>CircuitPythonDevice.deviceName</h4>
<b>deviceName</b>(<i></i>)
<p>
        Public method to get the name of the device.
</p>

<dl>
<dt>Return:</dt>
<dd>
name of the device
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="CircuitPythonDevice.disconnectFromLan" ID="CircuitPythonDevice.disconnectFromLan"></a>
<h4>CircuitPythonDevice.disconnectFromLan</h4>
<b>disconnectFromLan</b>(<i></i>)
<p>
        Public method  to disconnect from the LAN.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.disconnectWifi" ID="CircuitPythonDevice.disconnectWifi"></a>
<h4>CircuitPythonDevice.disconnectWifi</h4>
<b>disconnectWifi</b>(<i></i>)
<p>
        Public method to disconnect a device from the WiFi network.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.forceInterrupt" ID="CircuitPythonDevice.forceInterrupt"></a>
<h4>CircuitPythonDevice.forceInterrupt</h4>
<b>forceInterrupt</b>(<i></i>)
<p>
        Public method to determine the need for an interrupt when opening the
        serial connection.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating an interrupt is needed
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.getBluetoothStatus" ID="CircuitPythonDevice.getBluetoothStatus"></a>
<h4>CircuitPythonDevice.getBluetoothStatus</h4>
<b>getBluetoothStatus</b>(<i></i>)
<p>
        Public method to get Bluetooth status data of the connected board.
</p>

<dl>
<dt>Return:</dt>
<dd>
list of tuples containing the translated status data label and
            the associated value
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of tuples of (str, str)
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.getConnectedClients" ID="CircuitPythonDevice.getConnectedClients"></a>
<h4>CircuitPythonDevice.getConnectedClients</h4>
<b>getConnectedClients</b>(<i></i>)
<p>
        Public method to get a list of connected clients.
</p>

<dl>
<dt>Return:</dt>
<dd>
a tuple containing a list of tuples containing the client MAC-Address
            and the RSSI (if supported and available) and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of ([(bytes, int)], str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.getDeviceScan" ID="CircuitPythonDevice.getDeviceScan"></a>
<h4>CircuitPythonDevice.getDeviceScan</h4>
<b>getDeviceScan</b>(<i>timeout=10</i>)
<p>
        Public method to perform a Bluetooth device scan.
</p>

<dl>

<dt><i>timeout</i> (int (optional))</dt>
<dd>
duration of the device scan in seconds (defaults
            to 10)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a dictionary with the scan results and
            an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (dict, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.getDocumentationUrl" ID="CircuitPythonDevice.getDocumentationUrl"></a>
<h4>CircuitPythonDevice.getDocumentationUrl</h4>
<b>getDocumentationUrl</b>(<i></i>)
<p>
        Public method to get the device documentation URL.
</p>

<dl>
<dt>Return:</dt>
<dd>
documentation URL of the device
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="CircuitPythonDevice.getDownloadMenuEntries" ID="CircuitPythonDevice.getDownloadMenuEntries"></a>
<h4>CircuitPythonDevice.getDownloadMenuEntries</h4>
<b>getDownloadMenuEntries</b>(<i></i>)
<p>
        Public method to retrieve the entries for the downloads menu.
</p>

<dl>
<dt>Return:</dt>
<dd>
list of tuples with menu text and URL to be opened for each
            entry
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of tuple of (str, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.getEthernetStatus" ID="CircuitPythonDevice.getEthernetStatus"></a>
<h4>CircuitPythonDevice.getEthernetStatus</h4>
<b>getEthernetStatus</b>(<i></i>)
<p>
        Public method to get Ethernet status data of the connected board.
</p>

<dl>
<dt>Return:</dt>
<dd>
list of tuples containing the translated status data label and
            the associated value
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of tuples of (str, str)
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.getWifiData" ID="CircuitPythonDevice.getWifiData"></a>
<h4>CircuitPythonDevice.getWifiData</h4>
<b>getWifiData</b>(<i></i>)
<p>
        Public method to get data related to the current WiFi status.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple of three dictionaries containing the WiFi status data
            for the WiFi client, access point and overall data
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (dict, dict, dict)
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.getWorkspace" ID="CircuitPythonDevice.getWorkspace"></a>
<h4>CircuitPythonDevice.getWorkspace</h4>
<b>getWorkspace</b>(<i>silent=False</i>)
<p>
        Public method to get the workspace directory.
</p>

<dl>

<dt><i>silent</i> (bool)</dt>
<dd>
flag indicating silent operations
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
workspace directory used for saving files
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="CircuitPythonDevice.hasBluetooth" ID="CircuitPythonDevice.hasBluetooth"></a>
<h4>CircuitPythonDevice.hasBluetooth</h4>
<b>hasBluetooth</b>(<i></i>)
<p>
        Public method to check the availability of Bluetooth.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the availability of Bluetooth
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.hasEthernet" ID="CircuitPythonDevice.hasEthernet"></a>
<h4>CircuitPythonDevice.hasEthernet</h4>
<b>hasEthernet</b>(<i></i>)
<p>
        Public method to check the availability of Ethernet.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating the availability of Ethernet
            and the Ethernet type
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.hasFlashMenuEntry" ID="CircuitPythonDevice.hasFlashMenuEntry"></a>
<h4>CircuitPythonDevice.hasFlashMenuEntry</h4>
<b>hasFlashMenuEntry</b>(<i></i>)
<p>
        Public method to check, if the device has its own flash menu entry.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating a specific flash menu entry
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.hasNetworkTime" ID="CircuitPythonDevice.hasNetworkTime"></a>
<h4>CircuitPythonDevice.hasNetworkTime</h4>
<b>hasNetworkTime</b>(<i></i>)
<p>
        Public method to check the availability of network time functions.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the availability of network time functions
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.hasWifi" ID="CircuitPythonDevice.hasWifi"></a>
<h4>CircuitPythonDevice.hasWifi</h4>
<b>hasWifi</b>(<i></i>)
<p>
        Public method to check the availability of WiFi.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating the availability of WiFi
            and the WiFi type (circuitpython)
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<dl>

<dt>Raises <b>OSError</b>:</dt>
<dd>
raised to indicate an issue with the device
</dd>
</dl>
<a NAME="CircuitPythonDevice.isLanConnected" ID="CircuitPythonDevice.isLanConnected"></a>
<h4>CircuitPythonDevice.isLanConnected</h4>
<b>isLanConnected</b>(<i></i>)
<p>
        Public method to check the LAN connection status.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating that the device is connected to the LAN
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.isWifiApConnected" ID="CircuitPythonDevice.isWifiApConnected"></a>
<h4>CircuitPythonDevice.isWifiApConnected</h4>
<b>isWifiApConnected</b>(<i></i>)
<p>
        Public method to check the WiFi connection status as access point.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the WiFi connection status
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.isWifiClientConnected" ID="CircuitPythonDevice.isWifiClientConnected"></a>
<h4>CircuitPythonDevice.isWifiClientConnected</h4>
<b>isWifiClientConnected</b>(<i></i>)
<p>
        Public method to check the WiFi connection status as client.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the WiFi connection status
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.removeCredentials" ID="CircuitPythonDevice.removeCredentials"></a>
<h4>CircuitPythonDevice.removeCredentials</h4>
<b>removeCredentials</b>(<i></i>)
<p>
        Public method to remove the saved credentials from the connected device.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.removeLanAutoConnect" ID="CircuitPythonDevice.removeLanAutoConnect"></a>
<h4>CircuitPythonDevice.removeLanAutoConnect</h4>
<b>removeLanAutoConnect</b>(<i></i>)
<p>
        Public method to remove the saved IPv4 parameters from the connected device.
</p>
<p>
        Note: This disables the LAN auto-connect feature.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.runScript" ID="CircuitPythonDevice.runScript"></a>
<h4>CircuitPythonDevice.runScript</h4>
<b>runScript</b>(<i>script</i>)
<p>
        Public method to run the given Python script.
</p>

<dl>

<dt><i>script</i> (str)</dt>
<dd>
script to be executed
</dd>
</dl>
<a NAME="CircuitPythonDevice.scanNetworks" ID="CircuitPythonDevice.scanNetworks"></a>
<h4>CircuitPythonDevice.scanNetworks</h4>
<b>scanNetworks</b>(<i></i>)
<p>
        Public method to scan for available WiFi networks.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing the list of available networks as a tuple of 'Name',
            'MAC-Address', 'channel', 'RSSI' and 'security' and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (list of tuple of (str, str, int, int, str), str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.setButtons" ID="CircuitPythonDevice.setButtons"></a>
<h4>CircuitPythonDevice.setButtons</h4>
<b>setButtons</b>(<i></i>)
<p>
        Public method to enable the supported action buttons.
</p>

<a NAME="CircuitPythonDevice.setConnected" ID="CircuitPythonDevice.setConnected"></a>
<h4>CircuitPythonDevice.setConnected</h4>
<b>setConnected</b>(<i>connected</i>)
<p>
        Public method to set the connection state.
</p>

<dl>

<dt><i>connected</i> (bool)</dt>
<dd>
connection state
</dd>
</dl>
<a NAME="CircuitPythonDevice.setNetworkTime" ID="CircuitPythonDevice.setNetworkTime"></a>
<h4>CircuitPythonDevice.setNetworkTime</h4>
<b>setNetworkTime</b>(<i>server="0.pool.ntp.org", tzOffset=0, timeout=10</i>)
<p>
        Public method to set the time to the network time retrieved from an
        NTP server.
</p>

<dl>

<dt><i>server</i> (str (optional))</dt>
<dd>
name of the NTP server to get the network time from
            (defaults to "0.pool.ntp.org")
</dd>
<dt><i>tzOffset</i> (int (optional))</dt>
<dd>
offset with respect to UTC (defaults to 0)
</dd>
<dt><i>timeout</i> (int)</dt>
<dd>
maximum time to wait for a server response in seconds
            (defaults to 10)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error string
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.setWorkspace" ID="CircuitPythonDevice.setWorkspace"></a>
<h4>CircuitPythonDevice.setWorkspace</h4>
<b>setWorkspace</b>(<i>workspacePath</i>)
<p>
        Public method to set the device workspace directory.
</p>

<dl>

<dt><i>workspacePath</i> (str)</dt>
<dd>
directory to be used for saving files
</dd>
</dl>
<a NAME="CircuitPythonDevice.showCircuitPythonVersions" ID="CircuitPythonDevice.showCircuitPythonVersions"></a>
<h4>CircuitPythonDevice.showCircuitPythonVersions</h4>
<b>showCircuitPythonVersions</b>(<i></i>)
<p>
        Public slot to show the CircuitPython version of a connected device and
        the latest available one (from Github).
</p>

<a NAME="CircuitPythonDevice.startAccessPoint" ID="CircuitPythonDevice.startAccessPoint"></a>
<h4>CircuitPythonDevice.startAccessPoint</h4>
<b>startAccessPoint</b>(<i>ssid, security=None, password=None, hostname=None, ifconfig=None, </i>)
<p>
        Public method to start the access point interface.
</p>

<dl>

<dt><i>ssid</i> (str)</dt>
<dd>
SSID of the access point
</dd>
<dt><i>security</i> (int (optional))</dt>
<dd>
security method (defaults to None)
</dd>
<dt><i>password</i> (str (optional))</dt>
<dd>
password (defaults to None)
</dd>
<dt><i>hostname</i> (str (optional))</dt>
<dd>
host name of the device (defaults to None)
</dd>
<dt><i>ifconfig</i> (tuple of (str, str, str, str))</dt>
<dd>
IPv4 configuration for the access point if not default
            (IPv4 address, netmask, gateway address, DNS server address)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.stopAccessPoint" ID="CircuitPythonDevice.stopAccessPoint"></a>
<h4>CircuitPythonDevice.stopAccessPoint</h4>
<b>stopAccessPoint</b>(<i></i>)
<p>
        Public method to stop the access point interface.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containg a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.supportsLocalFileAccess" ID="CircuitPythonDevice.supportsLocalFileAccess"></a>
<h4>CircuitPythonDevice.supportsLocalFileAccess</h4>
<b>supportsLocalFileAccess</b>(<i></i>)
<p>
        Public method to indicate file access via a local directory.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating file access via local directory
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="CircuitPythonDevice.writeCredentials" ID="CircuitPythonDevice.writeCredentials"></a>
<h4>CircuitPythonDevice.writeCredentials</h4>
<b>writeCredentials</b>(<i>ssid, password, hostname, _country</i>)
<p>
        Public method to write the given credentials to the connected device and modify
        the start script to connect automatically.
</p>

<dl>

<dt><i>ssid</i> (str)</dt>
<dd>
SSID of the network to connect to
</dd>
<dt><i>password</i> (str)</dt>
<dd>
password needed to authenticate
</dd>
<dt><i>hostname</i> (str)</dt>
<dd>
host name of the device
</dd>
<dt><i>_country</i> (str)</dt>
<dd>
WiFi country code (unused)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<a NAME="CircuitPythonDevice.writeLanAutoConnect" ID="CircuitPythonDevice.writeLanAutoConnect"></a>
<h4>CircuitPythonDevice.writeLanAutoConnect</h4>
<b>writeLanAutoConnect</b>(<i>config, hostname</i>)
<p>
        Public method to generate a script and associated configuration to connect the
        device to the LAN during boot time.
</p>

<dl>

<dt><i>config</i> (str or tuple of (str, str, str, str))</dt>
<dd>
configuration for the connection (either the string 'dhcp'
            for a dynamic address or a tuple of four strings with the IPv4 parameters.
</dd>
<dt><i>hostname</i> (str)</dt>
<dd>
host name of the device
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing a flag indicating success and an error message
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (bool, str)
</dd>
</dl>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="createDevice" ID="createDevice"></a>
<h2>createDevice</h2>
<b>createDevice</b>(<i>microPythonWidget, deviceType, vid, pid, boardName, _serialNumber</i>)
<p>
    Function to instantiate a MicroPython device object.
</p>

<dl>

<dt><i>microPythonWidget</i> (MicroPythonWidget)</dt>
<dd>
reference to the main MicroPython widget
</dd>
<dt><i>deviceType</i> (str)</dt>
<dd>
device type assigned to this device interface
</dd>
<dt><i>vid</i> (int)</dt>
<dd>
vendor ID
</dd>
<dt><i>pid</i> (int)</dt>
<dd>
product ID
</dd>
<dt><i>boardName</i> (str)</dt>
<dd>
name of the board
</dd>
<dt><i>_serialNumber</i> (str)</dt>
<dd>
serial number of the board (unused)
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
reference to the instantiated device object
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
CircuitPythonDevice
</dd>
</dl>
<div align="right"><a href="#top">Up</a></div>
<hr />
</body></html>
